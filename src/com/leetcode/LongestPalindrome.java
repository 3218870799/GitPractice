package com.leetcode;

public class LongestPalindrome {
	
	class Solution {
	    public String longestPalindrome(String s) {
	    	//先预处理字符串
			StringBuffer str  = new StringBuffer();
			int lenTemp = s.length();
			str.append('#');
			for(int i=0;i<lenTemp;i++){
				str.append(s.charAt(i));
				str.append('#');
			}
	    	//处理后的字符串长度
	    	int len = str.length();
	    	//右边界
	    	int rightSide = 0;
	    	//右边界对应的回文串中心
	    	int rightSideCenter = 0;
	    	//保存以每个字符为中心的回文长度一半（向下取整）
	    	int[] halfLenArr = new int[len];
	    	//记录回文中心长度
	    	int center = 0;
	    	//记录最长回文长度
	    	int longestHalf = 0;
	    	
	    	for(int i = 0; i<len;i++){
	            // 是否需要中心扩展
	            boolean needCalc = true;
	            // 如果在右边界的覆盖之内
	            if(rightSide > i) {
	                // 计算相对rightSideCenter的对称位置
	                int leftCenter = 2 * rightSideCenter - i;
	                // 根据回文性质得到的结论
	                halfLenArr[i] = halfLenArr[leftCenter];
	                // 如果超过了右边界，进行调整
	                if(i + halfLenArr[i] > rightSide) {
	                    halfLenArr[i] = rightSide - i;
	                }
	                // 如果根据已知条件计算得出的最长回文小于右边界，则不需要扩展了
	                if(i + halfLenArr[leftCenter] < rightSide) {
	                    // 直接推出结论
	                    needCalc = false;
	                }
	            }
	            // 中心扩展
	            if(needCalc) {
	                while(i - 1 - halfLenArr[i] >= 0 && i + 1 + halfLenArr[i] < len) {
	                    if(str.charAt(i + 1 + halfLenArr[i]) == str.charAt(i - 1 - halfLenArr[i])) {
	                        halfLenArr[i]++;
	                    } else {
	                        break;
	                    }
	                }
	                // 更新右边界及中心
	                rightSide = i + halfLenArr[i];
	                rightSideCenter = i;
	                // 记录最长回文串
	                if(halfLenArr[i] > longestHalf) {
	                    center = i;
	                    longestHalf = halfLenArr[i];
	                }
	            }
	    	}
	        // 去掉之前添加的#
	        StringBuffer sb = new StringBuffer();
	        for(int i = center - longestHalf + 1; i <= center + longestHalf; i += 2) {
	            sb.append(str.charAt(i));
	        }
	        return sb.toString();
	    }
	}

	public String preHandleString(String s) {
		StringBuffer sb  = new StringBuffer();
		int len = s.length();
		sb.append('#');
		for(int i=0;i<len;i++){
			sb.append(s.charAt(i));
			sb.append('#');
		}
		return sb.toString();
	}
	
	class SolutionBest {
	    public String longestPalindrome(String s) {
	        if (s == null || s.length() < 1){
	            return "";
	        }
	        int maxLength = 0;
	        int center = 0;
	        for (int i = 0; i < s.length(); i++) {
	            // 最长回文串长度为奇数
	            int begin = centerExpand(s, i, i);
	            // 最长回文串长度为偶数
	            int end = centerExpand(s, i, i + 1);
	            if (maxLength < Math.max(begin, end)) {
	                // 以center为中心
	                center = i;
	                // 最长回文串长度
	                maxLength = Math.max(begin, end);
	            }
	        }
	        // 如果我们的回文串的长度为偶数，那么中心左边的长度会比右边的长度小1
	        return s.substring(center - (maxLength - 1) / 2, center + maxLength / 2 + 1);
	    }

	    private int centerExpand(String s, int left, int right) {
	        int L = left, R = right;
	        while (L >= 0 && R < s.length() && s.charAt(L) == s.charAt(R)) {
	            L--;
	            R++;
	        }
	        return R - L - 1;
	    }
	}
	

}
